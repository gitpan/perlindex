*** pp.c.orig	Sat Feb  3 00:18:35 1996
--- pp.c	Sat Feb 10 11:00:29 1996
***************
*** 2737,2742 ****
--- 2737,2766 ----
  		PUSHs(sv_2mortal(sv));
  	    }
  	    break;
+ 	case 'w':
+ 	    along = (strend - s) / sizeof(char);
+ 	    if (len > along)
+ 		len = along;
+ 	    EXTEND(SP, len);
+             { 
+               I32 foo;
+               foo = 0;
+               while  (len > 0) {
+                 if (s >= strend) {
+                   break;
+                 }
+                 foo = (foo << 7) | (*s & 0x7f);
+                 if (!(*s & 0x80)) {
+                   sv = NEWSV(40, 0);
+                   sv_setiv(sv, (I32) foo);
+                   PUSHs(sv_2mortal(sv));
+                   len--;
+                   foo = 0;
+                 } 
+                 s++;
+               }
+             }
+ 	    break;
  	case 'P':
  	    EXTEND(SP, 1);
  	    if (sizeof(char*) > strend - s)
***************
*** 3210,3215 ****
--- 3234,3269 ----
  		sv_catpvn(cat, (char*)&auint, sizeof(unsigned int));
  	    }
  	    break;
+ 	case 'w':
+             while (len-- > 0) {
+               int size;             /* bytes necessary to store the integer*/
+               unsigned char buf[4]; /* buffer fro compressed int */
+               register int  i;      /* loops over bytes of buf */
+ 
+               fromstr = NEXTFROM;
+               auint = U_I(SvNV(fromstr));
+               if (auint < 128) {
+                 size = 1;
+               } else if (auint < 16384) {
+                 size = 2;
+               } else if (auint < 2097152) {
+                 size = 3;
+               } else if (auint < 268435456) {
+                 size = 4;
+               } else {
+                 croak("Integer too big to compress");
+               }
+               for (i=size-1; i>=0; i--) {
+                 register unsigned char c;
+ 
+                 c = auint & 0x7f;
+                 if (i != (size-1)) c |= 0x80; /* set continue bit */
+                 auint = auint >> 7;
+                 buf[i] = c;
+               }
+               sv_catpvn(cat, (char*) buf, size);
+             }
+             break;
  	case 'i':
  	    while (len-- > 0) {
  		fromstr = NEXTFROM;
*** t/op/pack.t.orig	Tue Oct 18 17:45:42 1994
--- t/op/pack.t	Sat Feb 10 11:00:29 1996
***************
*** 2,8 ****
  
  # $RCSfile: compressed_int_patch,v $$Revision: 1.1.1.1 $$Date: 1996/02/22 15:43:19 $
  
! print "1..8\n";
  
  $format = "c2x5CCxsdila6";
  # Need the expression in here to force ary[5] to be numeric.  This avoids
--- 2,8 ----
  
  # $RCSfile: compressed_int_patch,v $$Revision: 1.1.1.1 $$Date: 1996/02/22 15:43:19 $
  
! print "1..12\n";
  
  $format = "c2x5CCxsdila6";
  # Need the expression in here to force ary[5] to be numeric.  This avoids
***************
*** 40,42 ****
--- 40,54 ----
  $sum = unpack("%32b*", $foo);
  $longway = unpack("b*", $foo);
  print $sum == $longway =~ tr/1/1/ ? "ok 8\n" : "not ok 8\n";
+ 
+ @x = (5,130,256,560,32000,3097152,268435455);
+ $x = pack('w*', @x);
+ $y = "\005\201\002\202\000\204\060\201\372\000\201\275\204\100\377\377\377\177";
+ print $x eq $y ? "ok 9\n" : "not ok 9\n";
+ @y = unpack('w*', $y);
+ $a = join ':', @x;
+ $b = join ':', @y;
+ print $a eq $b ? "ok 10\n" : "not ok 10\n";
+ @y = unpack('w2', $x);
+ print scalar(@y) == 2 ? "ok 11\n" : "not ok 11\n";
+ print $y[1] == 130 ? "ok 12\n" : "not ok 12\n";
*** pod/perlfunc.pod.orig	Thu Feb  1 19:36:46 1996
--- pod/perlfunc.pod	Sat Feb 10 11:00:30 1996
***************
*** 1840,1845 ****
--- 1840,1846 ----
      x	A null byte.
      X	Back up a byte.
      @	Null fill to absolute position.
+     w   A compressed unsigned int. Range is 0 to 268435456 (4*7 bits).
  
  Each letter may optionally be followed by a number which gives a repeat
  count.  With all types except "a", "A", "b", "B", "h" and "H", and "P" the
